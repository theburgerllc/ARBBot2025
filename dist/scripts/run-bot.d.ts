interface CLIConfig {
    simulate: boolean;
    verbose: boolean;
    help: boolean;
    crossChain: boolean;
    triangular: boolean;
}
interface ArbitrageOpportunity {
    id: string;
    tokenA: string;
    tokenB: string;
    amountIn: string;
    expectedProfit: string;
    netProfit: string;
    sushiFirst: boolean;
    path: string[];
    gasEstimate: string;
    gasCost: string;
    timestamp: number;
    isTriangular?: boolean;
    chainId: number;
    priority: number;
    spread: number;
    slippage: number;
    flashLoanProvider: 'BALANCER' | 'AAVE';
    flashLoanFee: string;
}
interface CrossChainOpportunity {
    id: string;
    tokenA: string;
    tokenB: string;
    amountIn: string;
    arbitrumPrice: string;
    optimismPrice: string;
    spread: string;
    estimatedProfit: string;
    bridgeCost: string;
    netProfit: string;
    timestamp: number;
    profitable: boolean;
    alertLevel: 'info' | 'warning' | 'critical';
}
declare class EnhancedMEVBot {
    private arbitrumProvider;
    private optimismProvider;
    private executorSigner;
    private authSigner;
    private optimismExecutor;
    private flashbotsProvider;
    private mevShareClient;
    private gasOptimizer;
    private l2GasManager;
    private mevBundleOptimizer;
    private triangularArbManager;
    private dynamicSlippageManager;
    private adaptiveProfitManager;
    private advancedRiskManager;
    private oraclePriceValidator;
    private optimizationCoordinator;
    private arbBotContract;
    private optBotContract;
    private arbBalancerVault;
    private optBalancerVault;
    private arbAavePool;
    private optAavePool;
    private arbUniV2Router;
    private arbSushiRouter;
    private arbUniV3Quoter;
    private optUniV2Router;
    private optSushiRouter;
    private optUniV3Quoter;
    private readonly TOKENS_ARB;
    private readonly TOKENS_OPT;
    private readonly ROUTERS_ARB;
    private readonly ROUTERS_OPT;
    private readonly AAVE_POOLS;
    private readonly TRADING_PAIRS;
    private readonly MIN_PROFIT_THRESHOLD;
    private readonly MIN_CROSS_CHAIN_SPREAD;
    private readonly CRITICAL_SPREAD_THRESHOLD;
    private readonly MAX_SLIPPAGE;
    private readonly BUNDLE_TIMEOUT;
    private readonly PRICE_UPDATE_INTERVAL;
    private readonly GAS_LIMIT;
    private readonly MAX_PRIORITY_FEE;
    private readonly COOLDOWN_PERIOD;
    private lastExecutionTime;
    private isRunning;
    private crossChainEnabled;
    private triangularEnabled;
    private simulationMode;
    private verboseMode;
    private circuitBreakerTripped;
    private totalProfit;
    private totalLoss;
    private executionCount;
    private opportunityCache;
    private simulationStats;
    constructor(cliConfig?: Partial<CLIConfig>);
    private initializeConfiguration;
    private setupProviders;
    private setupSigners;
    private initializeContracts;
    private initializeOptimizationModules;
    private checkAaveLiquidity;
    private checkBalancerLiquidity;
    private selectOptimalFlashLoanProvider;
    private calculateProviderScore;
    private monitorLiquidityHealth;
    initialize(): Promise<void>;
    executeArbitrage(opportunity: ArbitrageOpportunity): Promise<boolean>;
    private performStaticSimulation;
    private updateSimulationStats;
    private printSimulationSummary;
    scanForArbitrageOpportunities(): Promise<ArbitrageOpportunity[]>;
    scanCrossChainOpportunities(): Promise<CrossChainOpportunity[]>;
    private createMEVBundle;
    private submitMEVBundle;
    private estimateGasSettings;
    private convertToLegacyFormat;
    private checkCircuitBreaker;
    monitorAndExecute(): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    private getCurrentCapital;
    private estimateGasCost;
    private executeWithPhase3Optimization;
    private executeOptimizedTrade;
    private executeWithPhase2Fallback;
    private enhancedMonitoringCycle;
}
export { EnhancedMEVBot };
